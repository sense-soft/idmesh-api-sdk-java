/*
 * IDMesh-Dev
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.4.7
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.idmesh.auth;

import com.idmesh.*;
import org.bouncycastle.crypto.digests.SM3Digest;
import org.bouncycastle.crypto.macs.HMac;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.jce.provider.BouncyCastleProvider;

import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.math.BigInteger;
import java.net.URI;
import java.security.Security;
import java.util.*;

public class AccessKeyAuth implements Authentication{
    private final String ENCODING = "UTF-8";

    {
        Security.addProvider(new BouncyCastleProvider());
    }
    private String ak;
    private String sk;

    public AccessKeyAuth(String ak, String sk) {
        this.ak = ak;
        this.sk = sk;
    }

    private final List<String> SIGN_KEYS = Arrays.asList("nonce", "timestamp");

    public boolean isEmpty(String str) {
        return str == null || str.length() == 0;
    }
    public boolean isTrimEmpty(String str) {
        return str == null || str.trim().length() == 0;
    }

    // 生成指定位数的随机字符串
    public String getRandomString(int length) {
        String str = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < length; i++) {
            int index = (int)(Math.random() * str.length());
            sb.append(str.charAt(index));
        }
        return sb.toString();
    }

    public Long getTimestamp() {
        return System.currentTimeMillis();
    }

    public String getSign(List<Pair> params, String path, String ak, String sk, String nonce, Long timestamp) {
        StringBuilder sb = new StringBuilder(path);
        if (params == null) {
            params = new ArrayList<>();
        }
        params.add(new Pair("nonce", nonce));
        params.add(new Pair("timestamp", String.valueOf(timestamp)));
        params.sort(Comparator.comparing(Pair::getName));
        for (Pair param : params) {
            int i = SIGN_KEYS.indexOf(param.getName());
            if(i >= 0) {
                sb.append(param.getName()).append("=").append(param.getValue());
                if (i < SIGN_KEYS.size() - 1) {
                    sb.append("&");
                }
            }
        }
        sb.append(sk);
        String sign = encrypt(sb.toString());
        sign = nonce + "$" + timestamp + "$v2$" + ak + "$sm3$" + sign;
        return sign;
    }

    /**
     * sm3算法加密
     *
     * @param paramStr 待加密字符串
     * @return 返回加密后，固定长度=32的16进制字符串
     * @explain
     */
    public String encrypt(String paramStr) {
        // 将返回的hash值转换成16进制字符串
        String resultHexString = "";
        try {
            // 将字符串转换成byte数组
            byte[] srcData = paramStr.getBytes(ENCODING);
            // 调用hash()
            byte[] resultHash = hash(srcData);
            // 将返回的hash值转换成16进制字符串
            resultHexString = byteArrayToHexString(resultHash);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return resultHexString;
    }

    /**
     * 返回长度=32的byte数组
     *
     * @param srcData
     * @return
     * @explain 生成对应的hash值
     */
    public byte[] hash(byte[] srcData) {
        SM3Digest digest = new SM3Digest();
        digest.update(srcData, 0, srcData.length);
        byte[] hash = new byte[digest.getDigestSize()];
        digest.doFinal(hash, 0);
        return hash;
    }

    /**
     * sm3算法加密
     *
     * @param paramStr 待加密字符串
     * @param key      密钥
     * @return 返回加密后，固定长度=32的16进制字符串
     * @explain
     */
    public String encryptPlus(String paramStr, String key) {
        // 将返回的hash值转换成16进制字符串
        String resultHexString = "";
        try {
            // 将字符串转换成byte数组
            byte[] srcData = paramStr.getBytes(ENCODING);
            // 调用hash()
            byte[] resultHash = hmac(srcData, key.getBytes(ENCODING));
            // 将返回的hash值转换成16进制字符串
            resultHexString = byteArrayToHexString(resultHash);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return resultHexString;
    }

    /**
     * 通过密钥进行加密
     *
     * @param key     密钥
     * @param srcData 被加密的byte数组
     * @return
     * @explain 指定密钥进行加密
     */
    public byte[] hmac(byte[] key, byte[] srcData) {
        KeyParameter keyParameter = new KeyParameter(key);
        SM3Digest digest = new SM3Digest();
        HMac mac = new HMac(digest);
        mac.init(keyParameter);
        mac.update(srcData, 0, srcData.length);
        byte[] result = new byte[mac.getMacSize()];
        mac.doFinal(result, 0);
        return result;
    }

    /**
     * 判断源数据与加密数据是否一致
     *
     * @param srcStr       原字符串
     * @param sm3HexString 16进制字符串
     * @return 校验结果
     * @explain 通过验证原数组和生成的hash数组是否为同一数组，验证2者是否为同一数据
     */
    public boolean verify(String srcStr, String sm3HexString) {
        boolean flag = false;
        try {
            byte[] srcData = srcStr.getBytes(ENCODING);
            byte[] sm3Hash = hexStringToByteArray(sm3HexString);
            byte[] newHash = hash(srcData);
            if (Arrays.equals(newHash, sm3Hash))
                flag = true;
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return flag;
    }


    public String getSign(Object body, String path, String ak, String sk, String nonce, Long timestamp) {
        TreeMap<String, Object> map = printObjectProperties(body);
        map.put("nonce", nonce);
        map.put("timestamp", timestamp);
        List<Pair> params = new ArrayList<>();
        for (Map.Entry<String, Object> entry : map.entrySet()) {
            params.add(new Pair(entry.getKey(), entry.getValue().toString()));
        }
        return this.getSign(params, path, ak, sk, nonce, timestamp);
    }


    public TreeMap<String, Object> printObjectProperties(Object obj) {
        // 获取对象的类
        Class<?> clazz = obj.getClass();

        // 获取类的所有字段
        Field[] fields = clazz.getDeclaredFields();
        TreeMap<String, Object> map = new TreeMap<>();
        // 遍历字段并获取对应的值
        for (Field field : fields) {
            field.setAccessible(true); // 设置为可访问，即使是私有字段

            try {
                Object value = field.get(obj);
                map.put(field.getName(), value);
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }
        return map;
    }

    public static byte[] hexStringToByteArray(String hexString) {
        int length = hexString.length();

        // Ensure the hexString has an even length
        if (length % 2 != 0) {
            throw new IllegalArgumentException("Hex string must have an even length");
        }

        byte[] result = new byte[length / 2];

        for (int i = 0; i < length; i += 2) {
            String hexByte = hexString.substring(i, i + 2);
            result[i / 2] = (byte) Integer.parseInt(hexByte, 16);
        }

        return result;
    }

    public static String byteArrayToHexString(byte[] bytes) {
        BigInteger bigInt = new BigInteger(1, bytes);
        String hexString = bigInt.toString(16);

        // Ensure the hexString has an even length by padding with zeros if needed
        int paddingLength = (bytes.length * 2) - hexString.length();
        if (paddingLength > 0) {
            return String.format("%0" + paddingLength + "d%s", 0, hexString);
        } else {
            return hexString;
        }
    }

    @Override
    public void applyToParams(List<Pair> queryParams, Map<String, String> headerParams, Map<String, String> cookieParams, String payload, String method, URI uri) throws ApiException {
        // add sign header
        if (isTrimEmpty(ak)) {
            throw new ApiException("ak is null");
        }
        if (isTrimEmpty(sk)) {
            throw new ApiException("sk is null");
        }
        String nonce = getRandomString(32);
        Long timestamp = getTimestamp();
        String sign = getSign(null, uri.getPath(), ak, sk, nonce, timestamp);
        headerParams.put("X-Idmesh-Signature", sign);
    }
}
